#include <iostream>
// Кодировка UTF-8

template <typename T> // 1-я ф-ция не работает
void my_swap(T a, T b) {
	T tmp = a;
	a = b;
	b = tmp;
}

template <typename T> // 2-я уже работает, через разыменование указателей
void p_swap(T* a, T* b) {
	T tmp = *a;
	*a = *b;
	*b = tmp;
}

template <typename T> // 
void ref_swap(T& a, T& b) {
	T tmp = a;
	a = b;
	b = tmp;
}

int main() {
	setlocale(LC_ALL, "Russian");
	int n, m;
	
	// Ссылки - параметры функций
	/*
	n = 10; m = 15;
	
	
	std::cout << n << " " << m << std::endl;
	//p_swap(&n, &m); // работает, но неудобно, т.к. нужно передавать адреса
	ref_swap(n, m); // передаем переменную
	std::cout << n << " " << m << std::endl;
	*/
	
	
	// Cсылки 
	/*
	// & - амперсант

	// Ссылка не может быть объявлена без инициализации.

	n = 10; m = 20;
	int& refn = n; // Ссылка, ассоциирующаяся с переменной n
	std::cout << "refn = " << refn << std::endl;
	refn = m;
	std::cout << "refn = " << refn << std::endl;
	std::cout << "n = " << n << std::endl;

	// Примечания:
	//	1) Ссылки всегда обязательно инициализируются. Нет аналога нейтрального указателя.
	//	2) Не существует операторов для работы над ссылкой. Все операции проводятся над объектом, с которым ссылка ассоциируется.
	//	3) Ссылка это обращение напрямую к памяти (разыменование указателя). Т.е. ссылка - псевдоним переменной. 
	*/










	return 0;
}